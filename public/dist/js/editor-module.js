// Generated by CoffeeScript 1.7.1
(function() {
  'use strict';
  angular.module('DLApp', ['ShadeApp']).config([
    '$httpProvider', function($httpProvider) {
      $httpProvider.defaults.useXDomain = true;
      return delete $httpProvider.defaults.headers.common['X-Requested-With'];
    }
  ]);

  _.kill_event = function(e) {
    if (_.isObject(e)) {
      e.cancelBubble = true;
      e.stopPropagation();
      return e.preventDefault();
    }
  };

  _.corsproxy = function(css_url) {
    var m;
    m = css_url.match(/https?:\/\/(.+)/);
    if (!m) {
      return false;
    }
    return "http://www.corsproxy.com/" + m[1];
  };

  _.position = function(elm) {
    var p;
    p = {
      x: elm.offsetLeft || 0,
      y: elm.offsetTop || 0
    };
    while (elm = elm.offsetParent) {
      p.x += elm.offsetLeft;
      p.y += elm.offsetTop;
    }
    return p;
  };

  String.prototype.toDash = function() {
    return this.replace(/([A-Z])/g, function($1) {
      return "-" + $1.toLowerCase();
    });
  };

  _.toDash = function(str) {
    return str.replace(/([A-Z])/g, function($1) {
      return "-" + $1.toLowerCase();
    });
  };

  _.mapKeys = function(object, callback, thisArg) {
    var result;
    result = {};
    callback = _.createCallback(callback, thisArg, 3);
    _.forOwn(object, function(value, key, object) {
      result[callback(value, key, object)] = value;
    });
    return result;
  };

}).call(this);
;// Generated by CoffeeScript 1.7.1
(function() {
  'use strict';
  var default_lc;

  default_lc = "/* Welcome to Dependency Language in JavaScript!\n Features:\n -Supported Formats:\n Numbers, Strings, arrays\n -Namespaces (format: '$ns') -Built-in Functions:\n f.abs, f.avg\n -Themes for the editor\n -Graph or table presentation of the graph\n -Click 'Run' above or alt+R */\n \n x=0;\n y=2;\n z=f.avg(x,y,6);";

  angular.module('DLApp').service('dndFile', function($rootScope) {
    var allowed_file_exts, default_drop, load_first_file_matching;
    allowed_file_exts = /\.(md|litcoffee|css)$/;
    load_first_file_matching = (function(_this) {
      return function(files, regexp) {
        var mdfile, reader;
        if (mdfile = (function() {
          var f, _i, _len;
          for (_i = 0, _len = files.length; _i < _len; _i++) {
            f = files[_i];
            if (regexp.test(f.name)) {
              return f;
            }
          }
        })()) {
          reader = new FileReader();
          reader.onload = function(e) {
            e.fileName = mdfile.name.replace(regexp, '');
            e.fileExt = mdfile.name.match(regexp)[1];
            return _this.callbacks.fileload(e);
          };
          return reader.readAsText(mdfile);
        }
      };
    })(this);
    default_drop = (function(_this) {
      return function(e) {
        var files;
        files = e.dataTransfer.files;
        if (files.length) {
          load_first_file_matching(files, /\.(md|litcoffee)$/);
          return load_first_file_matching(files, /\.(css)$/);
        }
      };
    })(this);
    this.callbacks = {
      active: function(e) {},
      inactive: function(e) {},
      fileload: function(e) {},
      drop: function(e) {},
      default_drop: default_drop
    };
    return {
      init: (function(_this) {
        return function(elm) {
          elm.addEventListener("dragenter", function(e) {
            _.kill_event(e);
            return _this.callbacks.active(e);
          });
          elm.addEventListener("dragover", function(e) {
            _.kill_event(e);
            return _this.callbacks.active(e);
          });
          elm.addEventListener("dragexit", function(e) {
            _.kill_event(e);
            return _this.callbacks.inactive(e);
          });
          return elm.addEventListener("drop", function(e) {
            _.kill_event(e);
            _this.callbacks.drop(e);
            return _this.callbacks.default_drop(e);
          });
        };
      })(this),
      onactive: (function(_this) {
        return function(cb) {
          return _this.callbacks.active = cb;
        };
      })(this),
      oninactive: (function(_this) {
        return function(cb) {
          return _this.callbacks.inactive = cb;
        };
      })(this),
      onfileload: (function(_this) {
        return function(cb) {
          return _this.callbacks.fileload = cb;
        };
      })(this),
      ondrop: (function(_this) {
        return function(cb, replace_default) {
          _this.callbacks.drop = cb;
          return _this.callbacks.default_drop = replace_default ? (function() {}) : default_drop;
        };
      })(this)
    };
  }).controller('DLCtrl', function($scope, $rootScope, $http, $filter, $element, $document, dndFile, Graph, graphService) {
    $scope.litcoffee = {
      code: default_lc
    };
    $scope.test = {
      test: default_lc
    };
    dndFile.init($element[0], dndFile.onactive(function() {
      return $scope.$apply(function() {
        return $scope.dragover = true;
      });
    }));
    dndFile.oninactive(function() {
      return $scope.$apply(function() {
        return $scope.dragover = false;
      });
    });
    $element[0].addEventListener('mousemove', function() {
      return $scope.$apply(function() {
        return $scope.dragover = false;
      });
    });
    dndFile.ondrop((function(e) {
      return $scope.$apply(function() {
        return $scope.dragover = false;
      });
    }), false);
    dndFile.onfileload(function(e) {
      return $scope.$apply(function() {
        var i, name, _ref;
        if ((_ref = e.fileExt) === 'md' || _ref === 'litcoffee') {
          return $scope.litcoffee = e.target.result;
        } else if (e.fileExt === 'css') {
          name = e.fileName;
          i = 0;
          while (name in $scope.styles.sheets) {
            name = "" + e.fileName + " " + (++i);
          }
          $scope.styles.sheets[name] = {
            source: 'dragged file',
            "native": false,
            css: e.target.result
          };
          return $scope.styles.active = name;
        }
      });
    });
    $document.keyup(function(e) {
      var col;
      if (e.altKey) {
        if (e.keyCode === 82) {
          $scope.DLrun(e);
        }
        if (col = $scope.cols[e.keyCode - 49]) {
          return $scope.$apply(col.show = !col.show);
        }
      }
    });
    $scope.styles = {
      active: 'control',
      sheets: {
        basics: {
          source: 'XML/shade.xml',
          "native": true
        },
        control: {
          source: 'XML/control.xml',
          "native": true
        }
      },
      external: '',
      editor: ''
    };
    $scope.copy_style = function(e, style_name) {
      var copy, i, name;
      _.kill_event(e);
      copy = _.clone($scope.styles.sheets[style_name]);
      style_name = style_name.match(/(.*?)(:? copy(:? \d+)?)?$/)[1];
      name = "" + style_name + " copy";
      i = 0;
      while (name in $scope.styles.sheets) {
        name = "" + style_name + " copy " + (++i);
      }
      copy["native"] = false;
      $scope.styles.sheets[name] = copy;
      return $scope.styles.active = name;
    };
    $scope.delete_style = function(e, style_name) {
      _.kill_event(e);
      delete $scope.styles.sheets[style_name];
      if ($scope.styles.active === style_name) {
        return $scope.styles.active = Object.keys($scope.styles.sheets)[0];
      }
    };
    $scope.DLrun = function(e) {
      if (e) {
        _.kill_event(e);
      }
      return Graph.getGraph($scope.litcoffee.code, $scope.styles, function(graph) {
        $scope.graph = graph.evaluate();
        return $rootScope.$broadcast('Run');
      });
    };
    $document.ready(function() {
      setTimeout($scope.DLrun, 100);
      return setTimeout($scope.DLrun, 300);
    });
    $scope.$watch('styles.active', function() {
      var styles;
      if ($scope.styles.active in $scope.styles.sheets) {
        styles = $scope.styles.sheets[$scope.styles.active];
        if (styles.css) {
          return $scope.styles.editor = $filter('prettifyCSS')($filter('deSassify')(styles.css));
        } else {
          return $http.get(styles.source).then(function(response) {
            styles.css = response.data;
            return $scope.styles.editor = $filter('prettifyCSS')($filter('deSassify')(styles.css));
          });
        }
      }
    });
    $scope.$watch('styles.editor', function() {
      if ($scope.styles.sheets[$scope.styles.active]) {
        return $scope.styles.sheets[$scope.styles.active].css = $scope.styles.editor;
      }
    });
    return $scope.$watch('styles.external', function() {
      if (!($scope.styles.external && /^(https?:\/\/)?(\w+\.)+[\w\/]+/.test($scope.styles.external))) {
        return;
      }
      return $http.get(_.corsproxy($scope.styles.external)).then(function(response) {
        var file_name, i, name;
        i = 0;
        file_name = $scope.styles.external.match(/.+?\/(\w+)\.css/);
        name = file_name && file_name[1] || "external";
        while (name in $scope.styles.sheets) {
          name = "external " + (++i);
        }
        $scope.styles.sheets[name] = {
          source: $scope.styles.external,
          css: response.data,
          external: true,
          edited: false
        };
        $scope.styles.active = name;
        return $scope.styles.external = '';
      });
    });
  }).directive('menu', function($compile, $rootScope) {
    return {
      scope: {
        col: '=',
        themes: '=',
        setTheme: '&'
      },
      restrict: 'C',
      controller: function($scope) {
        $scope.menuitems || ($scope.menuitems = {
          show: false
        });
        return $scope.$on('bg_click', function() {
          return $scope.$apply(function() {
            return $scope.menuitems.show = false;
          });
        });
      },
      link: function(scope, elm, attrs) {
        var menu_items;
        elm.children('.menu-title').bind('click', function(e) {
          var show;
          _.kill_event(e);
          show = !scope.menuitems.show;
          $rootScope.$broadcast('bg_click');
          return scope.$apply(function() {
            return scope.menuitems.show = show;
          });
        });
        menu_items = elm.children('.menu-items');
        menu_items.attr('ng-class', "{in:menuitems.show}");
        menu_items.bind('click', _.kill_event);
        return $compile(menu_items)(scope);
      }
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.7.1
(function() {
  angular.module('DLApp').directive('aceEditor', function() {
    return {
      restrict: 'A',
      require: '?ngModel',
      scope: false,
      link: function(scope, elm, attrs, ngModel) {
        var acee, session;
        scope.acee = acee = window.ace.edit(elm[0]);
        scope.session = session = acee.getSession();
        scope.mode = attrs.mode;
        scope.makeCompletions = function(prefix, collection, meta) {
          return collection.filter(function(elm) {
            return elm.substring(0, prefix.length).toUpperCase() === prefix.toUpperCase();
          }).map(function(elm) {
            return {
              name: elm,
              value: elm,
              meta: meta
            };
          });
        };
        acee.setTheme("ace/theme/solarized_light");
        acee.getSession().setMode("ace/mode/" + scope.mode);
        acee.setOptions({
          showGutter: true,
          enableCustomAutocompletion: true
        });
        acee.setReadOnly(false);
        acee.setHighlightActiveLine(false);
        acee.setShowPrintMargin(false);
        acee.commands.on("afterExec", function(e) {
          if (e.command.name === "insertstring" && /^[\w.]$/.test(e.args)) {
            acee.execCommand("startCustomAutocomplete");
          }
        });
        scope.themes = ['merbivore', 'merbivore_soft', 'mono_industrial', 'monokai', 'pastel_on_dark', 'solarized_dark', 'solarized_light', 'terminal', 'textmate', 'tomorrow', 'tomorrow_night', 'tomorrow_night_blue', 'tomorrow_night_eighties', 'twilight', 'vibrant_ink', 'xcode'];
        scope.setTheme = function(name) {
          return scope.acee.setTheme("ace/theme/" + name);
        };
        if (angular.isDefined(ngModel)) {
          ngModel.$formatters.push(function(value) {
            if (angular.isUndefined(value) || value === null) {
              return '';
            } else if (angular.isObject(value) || angular.isArray(value)) {
              throw new Error('ace-editor cannot use an object or an array as a model');
            }
            return value;
          });
          ngModel.$render = function() {
            return session.setValue(ngModel.$viewValue);
          };
        }
        return session.on('change', function(e) {
          var newValue;
          newValue = session.getValue();
          if (newValue !== scope.$eval(attrs.value) && !scope.$$phase && angular.isDefined(ngModel)) {
            return scope.$apply(function() {
              return ngModel.$setViewValue(newValue);
            });
          }
        });
      },
      controller: function($scope, $rootScope) {
        return $rootScope.$on('panel_resized', function() {
          return $scope.acee.resize();
        });
      }
    };
  }).directive('dlEditor', function(Graph) {
    return {
      restrict: 'A',
      scope: false,
      link: function(scope, elm, attrs) {
        var DLcompleter;
        scope.langTools = window.ace.require("ace/ext/language_tools");
        DLcompleter = {
          getCompletions: function(editor, session, pos, prefix, callback) {
            var functions, identifiers, nameList;
            if (session.$modeId !== "ace/mode/" + attrs.mode) {
              return callback(null, []);
            }
            identifiers = scope.makeCompletions(prefix, Object.keys(scope.graph.variables.variables), "variable");
            functions = scope.makeCompletions(prefix, Graph.getFunctions(), "function");
            nameList = identifiers.concat(functions);
            return callback(null, nameList);
          }
        };
        return scope.langTools.addCompleter(DLcompleter);
      }
    };
  }).directive('shadeEditor', function(Graph, ShadeIdentifiers) {
    return {
      restrict: 'A',
      scope: false,
      link: function(scope, elm, attrs) {
        var DLcompleter;
        scope.langTools = window.ace.require("ace/ext/language_tools");
        DLcompleter = {
          getCompletions: function(editor, session, pos, prefix, callback) {
            var nameList;
            if (session.$modeId !== "ace/mode/" + attrs.mode) {
              return callback(null, []);
            }
            nameList = [];
            _.each(ShadeIdentifiers, function(dict) {
              return nameList = nameList.concat(scope.makeCompletions(prefix, dict.keys, dict.type));
            });
            return callback(null, nameList);
          }
        };
        return scope.langTools.addCompleter(DLcompleter);
      }
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.7.1
(function() {
  angular.module('DLApp').directive('renderGraph', function() {
    return {
      restrict: 'E',
      require: '?ngModel',
      scope: false,
      controller: function($scope, $rootScope, $element, $compile, graphService, $document) {
        $scope.gshow = false;
        $scope.themes = ['Graph', 'Table'];
        $scope.elems = {};
        $scope.elems['Table'] = $compile('<div ng-hide="gshow"></div>')($scope);
        $scope.elems['Graph'] = $compile('<div ng-show="gshow"></div>')($scope);
        _.each($scope.elems, function(value) {
          return $element.append(value);
        });
        $rootScope.$on('Run', function() {
          return _.each($scope.themes, function(value) {
            graphService.deleteGraph(value);
            return graphService.drawGraph[value]($scope.graph, $scope.elems[value][0]);
          });
        });
        return $scope.setTheme = function(name) {
          var _ref, _ref1;
          graphService.deleteGraph((_ref = name === 'Graph') != null ? _ref : {
            'Table': 'Graph'
          });
          graphService.drawGraph[name]($scope.graph, $scope.elems[name][0]);
          return $scope.gshow = (_ref1 = name === 'Graph') != null ? _ref1 : {
            "true": false
          };
        };
      }
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.7.1
(function() {
  angular.module('DLApp').directive('splitRow', function() {
    return {
      restrict: 'E',
      transclude: true,
      scope: {
        styles: '=',
        graph: '=',
        cols: '=',
        col: '=',
        litcoffee: '='
      },
      replace: true,
      template: '<div class="split-row" ng-transclude></div>',
      controller: function($scope, $element, $compile, $rootScope, $window) {
        var body, cols, dragged;
        $scope.row = $element[0];
        cols = $scope.cols = [];
        $scope.col = function(name) {
          var c;
          return ((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = cols.length; _i < _len; _i++) {
              c = cols[_i];
              if (c.name === name) {
                _results.push(c);
              }
            }
            return _results;
          })())[0];
        };
        body = document.getElementsByTagName("body")[0];
        body.addEventListener('click', function(e) {
          return $rootScope.$broadcast('bg_click');
        });
        $(document).keyup(function(e) {
          if (e.keyCode === 27) {
            return $rootScope.$broadcast('bg_click');
          }
        });
        this.equalCols = function(ncols) {
          var c, new_ratio, _i, _len, _results;
          ncols || (ncols = ((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = cols.length; _i < _len; _i++) {
              c = cols[_i];
              if (c.show) {
                _results.push(c);
              }
            }
            return _results;
          })()).length);
          new_ratio = 1 / ncols;
          _results = [];
          for (_i = 0, _len = cols.length; _i < _len; _i++) {
            c = cols[_i];
            if (c.show) {
              _results.push(c.ratio = new_ratio);
            } else {
              _results.push(c.ratio = 0);
            }
          }
          return _results;
        };
        this.findLastCol = function() {
          var c, last_shown, _i, _len;
          if (!cols.length) {
            return;
          }
          last_shown = null;
          for (_i = 0, _len = cols.length; _i < _len; _i++) {
            c = cols[_i];
            c.last_shown = false;
            if (c.show) {
              last_shown = c;
            }
          }
          if (last_shown) {
            return last_shown.last_shown = true;
          }
        };
        this.addCol = function(col) {
          return $scope.$apply((function(_this) {
            return function() {
              col.index = cols.length;
              cols.push(col);
              _this.equalCols();
              return col.div.append($compile('<drag-area ng-show="!last_shown"></drag-area>')(col));
            };
          })(this));
        };
        $window.r = $scope.row;
        dragged = (function(_this) {
          return function(x) {
            return $scope.$apply(function() {
              var after, before, c, cumRatio, i;
              before = $scope.dragging;
              after = cols[i = before.index + 1];
              while (!after.show) {
                after = cols[++i];
              }
              cumRatio = ((function() {
                var _i, _len, _results;
                _results = [];
                for (_i = 0, _len = cols.length; _i < _len; _i++) {
                  c = cols[_i];
                  if (c.index < before.index) {
                    _results.push(c.ratio);
                  }
                }
                return _results;
              })()).reduce((function(t, s) {
                return t + s;
              }), 0);
              before.ratio = (x - $scope.row.offsetLeft) / _this.row_width - cumRatio;
              if (before.ratio < 0.1) {
                before.ratio = 0.1;
              }
              after.ratio = 1 - ((function() {
                var _results;
                _results = [];
                for (i in cols) {
                  if (parseInt(i) !== after.index) {
                    _results.push(cols[i].ratio);
                  }
                }
                return _results;
              })()).reduce((function(t, s) {
                return t + s;
              }), 0);
              if (after.ratio < 0.1) {
                after.ratio = 0.1;
                before.ratio = 1 - ((function() {
                  var _results;
                  _results = [];
                  for (i in cols) {
                    if (parseInt(i) !== before.index) {
                      _results.push(cols[i].ratio);
                    }
                  }
                  return _results;
                })()).reduce((function(t, s) {
                  return t + s;
                }), 0);
              }
              if (before.div[0].onresize) {
                before.div[0].onresize();
              }
              if (after.div[0].onresize) {
                after.div[0].onresize();
              }
              return $rootScope.$broadcast('panel_resized');
            });
          };
        })(this);
        ($scope.row.onresize = (function(_this) {
          return function() {
            return _this.row_width = $scope.row.offsetWidth;
          };
        })(this))();
        this.start_drag = function(col, e) {
          _.kill_event(e);
          return $scope.dragging = col;
        };
        document.onmousemove = function(e) {
          e.preventDefault();
          if ($scope.dragging) {
            dragged(e.clientX);
          }
          if (!e.caughtBy) {
            return $rootScope.$broadcast('mousemoved');
          }
        };
        document.onmouseup = function() {
          return $scope.dragging = null;
        };
      }
    };
  }).directive('resizablePanel', function($rootScope) {
    return {
      require: '^splitRow',
      restrict: 'E',
      transclude: true,
      scope: {
        name: '@',
        show: '@'
      },
      replace: true,
      template: '<div class="resizable-panel" ng-transclude ng-style="{width: \'\'+(ratio*100)+\'%\'}" ng-show="show"></div>',
      controller: function($scope, $rootScope) {
        return $scope.$watch('show', function() {
          $scope.show = !!$scope.show;
          $scope.ctrl.equalCols();
          $scope.ctrl.findLastCol();
          return setTimeout(function() {
            return $rootScope.$broadcast('panel_resized');
          });
        });
      },
      link: function(scope, elm, attrs, splitRowCtrl) {
        scope.themes = [];
        scope.div = elm;
        scope.ctrl = splitRowCtrl;
        scope.mouseover = false;
        setTimeout((function() {
          scope.show = !!scope.show;
          return splitRowCtrl.addCol(scope);
        }), 0);
        elm.bind('mousemove', function(e) {
          e.originalEvent.caughtBy = scope.name;
          if (!scope.mouseover) {
            return $rootScope.$broadcast('mousemoved', scope.name);
          }
        });
        return scope.$on('mousemoved', function(e, name) {
          return scope.$apply(function() {
            return scope.mouseover = name === scope.name;
          });
        });
      }
    };
  }).directive('dragArea', function() {
    return {
      restrict: 'E',
      replace: true,
      template: '<div class="drag-area"></div>',
      scope: false,
      link: function(scope, elm, attrs) {
        return elm.bind('mousedown', function(e) {
          return scope.ctrl.start_drag(scope, e);
        });
      }
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.7.1
(function() {
  'use strict';
  angular.module('DLApp').filter('indentHTML', function() {
    return function(html) {
      var indent;
      if (!html) {
        return;
      }
      indent = function(html) {
        var cl, i, ind, insert, k, n, op, open, str, _i;
        str = html;
        i = 1;
        k = 0;
        open = -1;
        insert = function() {
          return str = [str.slice(0, open), '#', Array(i).join('@'), str.slice(open)].join('');
        };
        ind = function(c) {
          return str.indexOf(c, open + i + k + 1);
        };
        for (n = _i = 1; _i <= 1000; n = ++_i) {
          open = ind('<');
          if (open === -1) {
            return str;
          }
          if (str.charAt(open + 1) === '/') {
            insert();
            i--;
            k = 1;
          } else {
            i++;
            insert();
            k = 0;
          }
          op = ind('<');
          cl = ind('/>');
          if (cl > -1 && op > cl) {
            k = 1;
            i--;
          }
        }
      };
      return indent(html, 1).replace(new RegExp('#', 'gi'), '\n').replace(new RegExp('@', 'gi'), '  ');
    };
  }).filter('md2html', function($interpolate, $rootScope) {
    return function(md) {
      if (md && md.replace(/\s*/, '')) {
        return markdown.toHTML(md);
      } else {
        return '';
      }
    };
  }).filter('shade2html', function(x2js) {
    return function(Shade) {
      var template, templateData;
      templateData = x2js.xml2json(Shade);
      _.extend(templateData, {
        'NodeHandlers': NodeHandlers
      });
      template = _.template($rootScope.shadeTemplate);
      return template(templateData);
    };
  }).filter('escapeHTML', function($interpolate, $rootScope) {
    return function(html) {
      if (html && html.replace(/\s*/, '')) {
        return html.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
      } else {
        return '';
      }
    };
  }).filter('scopeCSS', function($filter) {
    return function(css, prefix, prettify) {
      var blacklist, doc, response, scope_selectors, styles;
      doc = document.implementation.createHTMLDocument("");
      styles = document.createElement("style");
      styles.innerText = css;
      doc.body.appendChild(styles);
      blacklist = /(^| )(head|title|link|style|script)($| )/;
      response = '';
      scope_selectors = function(rules) {
        var contained_styles, cssText, i, line, mtch, n, prop_decl, prop_url_pairs, r, s, selector, selectors, splitter, url_content, url_selector, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2, _results;
        if (!rules.length) {
          return;
        }
        _results = [];
        for (i = _i = 0, _ref = rules.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          if (rules[i].selectorText) {
            selectors = rules[i].selectorText.split(', ');
            selector = ((function() {
              var _j, _len, _results1;
              _results1 = [];
              for (_j = 0, _len = selectors.length; _j < _len; _j++) {
                s = selectors[_j];
                if (!blacklist.test(s)) {
                  _results1.push(/(^| )(body|html)($| )/.test(s) ? s.replace(/(body|html)/, prefix) : "" + prefix + " " + s);
                }
              }
              return _results1;
            })()).join(', ');
            if (selector) {
              cssText = "";
              if (/url\(\)/.test(rules[i].cssText)) {
                n = 0;
                for (r in rules) {
                  if (rules[r].selectorText === rules[i].selectorText && parseInt(r) < i) {
                    n += 1;
                  }
                }
                splitter = RegExp(rules[i].selectorText + "\\s*\{");
                contained_styles = css.split(splitter)[n + 1].split('}')[0];
                prop_url_pairs = {};
                _ref1 = contained_styles.match(/\s*(.+?)\s*:.+?url\((.+?)\).*?;/g);
                for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
                  line = _ref1[_j];
                  mtch = line.match(/\s*([\-\w]+)\s*:.+?url\((.+?)\).*?;/);
                  url_selector = mtch[1].replace(/\s+/g, '');
                  url_content = mtch[2].replace(/\s+/g, '');
                  prop_url_pairs[url_selector] = url_content;
                }
                cssText += selector + ' { ';
                _ref2 = rules[i].cssText.match(/\{(.+)\}/)[1].split(';');
                for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
                  prop_decl = _ref2[_k];
                  if (!!~prop_decl.indexOf('url()')) {
                    url_selector = prop_decl.match(/\s*(.+?)\s*:.+/)[1].replace(/\s+/g, '');
                    url_content = prop_url_pairs[url_selector];
                    if (!url_content) {
                      if (url_selector === 'background-image') {
                        url_content = prop_url_pairs['background'];
                      }
                    }
                    prop_decl = prop_decl.replace('url()', 'url(' + url_content + ')');
                    cssText += prop_decl + '; ';
                  } else {
                    cssText += prop_decl + '; ';
                  }
                }
                cssText += ' } ';
              } else {
                rules[i].selectorText = selector;
                cssText = rules[i].cssText;
              }
              _results.push(response += cssText + '   ');
            } else {
              _results.push(void 0);
            }
          } else if (rules[i].media[0] === 'screen') {
            _results.push(scope_selectors(rules[i].cssRules));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };
      scope_selectors(styles.sheet.cssRules);
      return response;
    };
  }).filter('deSassify', function() {
    return function(css) {
      return css.replace( /@media -sass-debug-info.*?\{(?:.*?\{.*?\})+.*?\}/g, '');
    };
  }).filter('prettifyCSS', function() {
    return function(css) {
      return css
    .replace( /^\s+/g,    ''         )
    .replace( /\s*,\s*/g, ', '       )
    .replace( /\s*{\s*/g, ' {\n    ' )
    .replace( /\s*;\s*/g, ';\n    '  )
    .replace( /\*\//g,    '*/\n'     )
    .replace( /\n\n+/g,   '\n'       )
    .replace( /\s*}\s*/g, '\n}\n\n'  );
    };
  }).filter('prettifyHTML', function() {
    var closing, count_inline, indent, inline, tag_re;
    indent = function(n, inline_count) {
      if (n <= 0) {
        return "";
      } else {
        return Array(n - inline_count + 1).join('  ');
      }
    };
    inline = function(tag) {
      return tag === 'span' || tag === 'a' || tag === 'code' || tag === 'i' || tag === 'b' || tag === 'em' || tag === 'strong' || tag === 'abbr' || tag === 'img' || tag === 'h1' || tag === 'h2' || tag === 'h3' || tag === 'h4' || tag === 'h5' || tag === 'h6' || tag === 'bdi' || tag === 'bdo' || tag === 'wbr' || tag === 'kbd' || tag === 'del' || tag === 'ins' || tag === 's' || tag === 'rt' || tag === 'rp' || tag === 'var' || tag === 'time' || tag === 'sub' || tag === 'sup' || tag === 'link' || tag === 'title' || tag === 'label' || tag === 'input';
    };
    closing = function(tag) {
      return tag === 'area' || tag === 'br' || tag === 'col' || tag === 'embed' || tag === 'hr' || tag === 'img' || tag === 'input' || tag === 'keygen' || tag === 'link' || tag === 'meta' || tag === 'base' || tag === 'param' || tag === 'source' || tag === 'track' || tag === 'wbr';
    };
    count_inline = function(stack) {
      var t;
      return ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = stack.length; _i < _len; _i++) {
          t = stack[_i];
          if (inline(t)) {
            _results.push(t);
          }
        }
        return _results;
      })()).length;
    };
    tag_re = '<(?:(?:(\\w+)[^><]*?)|(?:\\/(\\w+)))>';
    tag_re = new RegExp(tag_re);
    tag_re.compile(tag_re);
    return function(html) {
      var i, inline_count, last_t, m, pretty_html, saved, stack, tag_name;
      saved = html;
      inline_count = 0;
      stack = [];
      pretty_html = "";
      while (html) {
        i = html.search(tag_re);
        if (!(i + 1)) {
          pretty_html += html;
          html = "";
        }
        m = html.match(tag_re);
        if (tag_name = m[1]) {
          if (inline(tag_name)) {
            if (pretty_html.charAt(pretty_html.length - 1) === '\n') {
              pretty_html += indent(stack.length, inline_count);
            }
            pretty_html += html.substr(0, i + m[0].length);
            stack.push(tag_name);
            inline_count += 1;
            html = html.substr(i + m[0].length);
          } else if (closing(tag_name)) {
            if (pretty_html.charAt(pretty_html.length - 1) === '\n') {
              pretty_html += indent(stack.length, inline_count);
            }
            pretty_html += html.substr(0, i + m[0].length);
            html = html.substr(i + m[0].length);
          } else {
            if (i && pretty_html.charAt(pretty_html.length - 1) === '\n') {
              pretty_html += indent(stack.length, inline_count);
            }
            pretty_html += "" + (html.substr(0, i));
            if (pretty_html.charAt(pretty_html.length - 1) !== '\n') {
              pretty_html += '\n';
            }
            pretty_html += indent(stack.length, inline_count) + m[0];
            stack.push(tag_name);
            pretty_html += '\n';
            html = html.substr(i + m[0].length);
          }
        } else if (tag_name = m[2]) {
          last_t = stack.lastIndexOf(tag_name);
          if (last_t + 1) {
            if (inline(tag_name)) {
              inline_count -= 1;
              stack.splice(last_t);
              pretty_html += "" + (html.substr(0, i)) + m[0];
              html = html.substr(i + m[0].length);
            } else {
              if (i && pretty_html.charAt(pretty_html.length - 1) === '\n') {
                pretty_html += indent(stack.length, inline_count);
              }
              stack.splice(last_t);
              inline_count = count_inline(stack);
              pretty_html += "" + (html.substr(0, i)) + (pretty_html.charAt(pretty_html.length - 1) === '\n' ? '' : '\n') + (indent(stack.length, inline_count)) + m[0];
              html = html.substr(i + m[0].length);
              if (html[0] !== '\n') {
                pretty_html += '\n';
              }
            }
          } else {
            pretty_html += "" + (html.substr(0, i + m[0].length));
            html = html.substr(i + m[0].length);
          }
        } else {
          console.warn("UH OH: found a tag that's not an opening tag or a closing tag!?!?");
        }
      }
      return pretty_html;
    };
  });

}).call(this);
;angular.module('DLApp').service('graphService', function() {
    
    var div_name = { 'Table': '#DLtable_wrapper', 'Graph': 'svg' };

    var graphState = function(theme,state) {$(div_name[theme]).css('display',state);};

    this.deleteGraph = function(theme) {$(div_name[theme]).remove();};

    this.hideGraph = function (theme) {graphState(theme,'none');};
    this.showGraph = function (theme) {graphState(theme,'');};

    var formatArrayObject = function (obj) {
        var cases = {'number':function(value){return value.toFixed(2)},
                     'object':function(value){return formatArrayObject(value)}};
        return "{"+ $.map(obj, function (value, index) {
            return (cases[typeof value] || function(v){return v})(value)
        }) + "}";
    }

    this.drawGraph = {
        'Table': function (_graph, div) {
            if ($('#DLtable_wrapper').length != 0) return;
            if (!_graph) return;
            var data = JSON.parse(JSON.stringify(_graph.variables.variables));
            var _v;
            for (var key in data) {
                var v = data[key];
                if (v.hasOwnProperty('expr')) {
                    for (var _key in v) {
                        var attr = v[_key];
                        if (attr && typeof attr == 'object' && _key == 'value')
                            v[_key] = formatArrayObject(attr);
                        else if (typeof attr == 'number')
                            v[_key] = attr.toFixed(2);
                        else if (typeof attr == 'function')
                            delete v[_key];
                    }
                }
                else delete data[key];
            }

            var tableData = [];
            $.each(data, function (index, value) {
                if (data.hasOwnProperty(index))
                    tableData.push([index].concat(_.toArray(value)));
            });
            for (var key in data)
                {_v = data[key]; break;}
            var tableColumns = [];
            tableColumns.push({ "sTitle": "name", "sClass": "center"});
            for (var attr in _v){
                if (_v.hasOwnProperty(attr))
                    tableColumns.push({ "sTitle": attr, "sClass": "center" });}
            $(div).append( '<table cellpadding ="0" cellspacing ="0" border="0" class = "display" id="DLtable"></table>');
            $('#DLtable').dataTable( {
            "aaData": tableData,
            "aoColumns": tableColumns
            });

            
        },
            

        'Graph': function(_graph,div) {

            if (!_graph) return;

            d3.select("svg")
                    .remove();

            var data = _.cloneDeep(_graph.variables);

            function ArrayObjectLookup(array, attr) {
                for (var i = 0; i< array.length; i++)
                    if(array[i].name == attr) return i;
                }
   
            var graph = {"nodes":[],"links":[]};
        
            for (var v in data.variables) {var _v = data.variables[v];
                if (_v.hasOwnProperty("expr")) {_v.name = v;graph.nodes.push(_v);}}
 
            $.each(data.edges, function (index, value){
                graph.links[index] = {"source":ArrayObjectLookup(graph.nodes,this[0]),"target":ArrayObjectLookup(graph.nodes,this[1])};});

            d3.selection.prototype.moveToFront = function() {
                return this.each(function(){
                this.parentNode.appendChild(this);
                });
            };

            var g_state = "";



            var canvas=$(div);

            while (!canvas.width() || !canvas.height())
                canvas = canvas.parent();
            
            var width = canvas.width(),
                height = canvas.height();

            var svg = d3.select(div).append("svg")
                .attr("width", width)
                .attr("height", height)
                .call(d3.behavior.zoom().scaleExtent([0.25, 2]).on("zoom", zoom)).on("dblclick.zoom",null)
                .append("g");

            var width_padding = 20;
            var height_padding = 20;

            var	div_area = (width-width_padding)*(height-height_padding),
	            num_nodes = graph.nodes.length,
	            node_area = div_area/(num_nodes+num_nodes%2),
                node_to_padding_ratio = 0.50,
	            node_dia_inc_pad = Math.sqrt(node_area),
	            node_radius_wo_pad = node_dia_inc_pad/2*node_to_padding_ratio,
	            node_padding = node_dia_inc_pad/2*(1-node_to_padding_ratio),
	            nodes_in_width = parseInt(width/(node_dia_inc_pad)) || 1,
                nodes_in_height = parseInt(height/(node_dia_inc_pad)) || 1;  

            var xScale = d3.scale.linear()
	            .domain([0,nodes_in_width])
	            .range([width_padding + node_radius_wo_pad,width - width_padding -node_radius_wo_pad]);

            var yScale = d3.scale.linear()
	            .domain([0,nodes_in_height])
	            .range([height_padding + node_radius_wo_pad,height - height_padding- node_radius_wo_pad]);

            var getX = function(index){return xScale(index%nodes_in_width)};
            var getY = function(index){return yScale(parseInt(index/nodes_in_width))};

            var lines = svg.append("g").attr("class", "line")
                .selectAll("line").data(graph.links)
                .enter().append("line")
                .attr("x1", function(d) {return getX(d.source); })
                .attr("y1", function(d) { return getY(parseInt(d.source)); })
                .attr("x2", function(d) { return getX(d.target); })
                .attr("y2", function(d) {  return getY(d.target); })
                .attr("src", function(d) {  return d.source; })
                .attr("trgt", function(d) {  return d.target; })
                .attr("viewed", function() {  return 0; })
                .attr("focused", function() {  return 0; })
                .style("stroke", "grey");
 
            var circles = svg.append("g")
                .attr("class","nodes")
                .selectAll("circle")
                .data(graph.nodes)
                .enter()
                .append("g")
                .attr("transform",function(d,i){d.x = getX(i);d.y=getY(i);return "translate(" + d.x + "," + d.y + ")";})
                .attr("name", function(d){return d.name;})
                .attr("viewed",  0)
	            .attr("focused", 0)
                .attr("index", function(d, i) {return i;});

            circles.append("circle")
                .style("stroke", "gray")
                .style("fill", "white")
                .attr("r", node_radius_wo_pad)
                .on("mouseover", function(){
                    g_elem = this.parentNode;
		            if (d3.select(g_elem).attr("focused")!=1 && g_state == "focus") return;
		            if (g_state == "focus") {d3.select(this).style("fill", "aliceblue"); return;}
		            d3.select(g_elem).attr("viewed",1);
		            var that = this;

		            renderViewed("red","src","trgt");
                    renderViewed("green","trgt","src");
                          
		            lines.filter(function() {
			            return d3.select(this).attr("viewed")==0;
		                }).transition().style("opacity", 0);

		            var toChange = circles.filter(function(){
			            return d3.select(this).attr("viewed")==0;
			            });
                    toChange .selectAll("circle").transition().style("opacity", 0.2);
                    toChange.selectAll("text").transition().style("opacity", 0.2);

		            d3.select(this).style("fill", "aliceblue");
	            })
                .on("mouseout", function(){
	                    if (g_state == "focus"){
		                    lines.filter(function(){return d3.select(this).attr("focused")==1;})
				                .style("stroke", "grey")
				                .attr("viewed",0)
			                    .transition().style("opacity", 1);

		                var toChange = circles.filter(function(){return d3.select(this).attr("focused")==1;})
                                                .attr("viewed",0);
                            toChange.selectAll("circle")
		    	                    .transition().style("opacity", 1);
                            toChange.selectAll("text")
		    	                    .transition().style("opacity", 1);
		  
		                    d3.select(this).style("fill", "white");
	                    }
	                    else {
		                    lines.style("stroke", "grey")
				                .attr("viewed",0)
			                    .transition().style("opacity", 1);
		                    circles.attr("viewed",0)
                                .selectAll("circle")
                                .style("stroke", "grey")
	       	                    .transition().style("opacity", 1);
                            circles.selectAll("text")
	       	                    .transition().style("opacity", 1);
		                    d3.select(this).style("fill", "white");
	                    }
                })

	            .on("dblclick", function(){
		            if (g_state == "focus") {
			
			            circles.attr("transform",function(d,i){return "translate(" + d.x + "," + d.y + ")";})
		                        .attr("viewed", function() {  return 0; })
				                .attr("focused", function() {  return 0; })
                                .selectAll("circle").attr("r", node_radius_wo_pad);      

			            lines.attr("x1", function(d) { return getX(d.source); })
			                    .attr("y1", function(d) { return getY(d.source); })
			                    .attr("x2", function(d) { return getX(d.target); })
			                    .attr("y2", function(d) {  return getY(d.target); });
			            lines.attr("viewed", function() {  return 0; })
			                    .attr("focused", function() {  return 0; })
			                    .style("stroke", "grey");
                        g_state = "";
			            return; 
		            }
		            g_state = "focus";
		            var node = d3.select(this.parentNode);
		            node.moveToFront();
		
		            node.attr("focused",1).attr("transform","translate("+width/2+","+height/2+")").selectAll("circle").attr("r",height/8);
        
		            var that = this.parentNode;

		            renderFocused("src","trgt",that);
                    renderFocused("trgt","src",that);

		                lines.filter(function() {
			                return d3.select(this).attr("focused") != 1;
	                    }).transition().style("opacity", 0);

		                var toChange =circles.filter(function(){
			                return d3.select(this).attr("focused") != 1;
			            });

                    toChange.selectAll("circle").transition().style("opacity", 0);
                    toChange.selectAll("text").transition().style("opacity", 0);
	            });

                circles.append("text")
                    .attr("text-anchor","middle")
                    .text(function(d){return d.name})
                    .attr("font-family", "sans-serif")
                    .attr("font-size", "50px")
                    .attr("y",10);

            function zoom() {
	                svg.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
	            }

            function renderViewed(color,src,trgt) {
      
                    lines.filter(function() {	
			            return d3.select(this).attr(src) == d3.select(g_elem).attr("index");
		                }).style("stroke", color).attr("viewed",1)
			            .each(function(){
				            var that = this;
				            circles.filter(function() {
					            return d3.select(this).attr("index") == d3.select(that).attr(trgt);
					            }).attr("viewed",1)
                                    .selectAll("circle").style("stroke", color)
                            });
            }

            function renderFocused(src,trgt,_that) {
                var x = src == "src" ? 1 : 3;
                var dep_radius = height/16;
                var nodes_in_wid = parseInt(width/dep_radius*2/node_to_padding_ratio);
                var matches=0;
		            lines.filter(function(d, i) {	
		                if (d3.select(this).attr(src) == d3.select(_that).attr("index")) matches++;
			            return d3.select(this).attr(src) == d3.select(_that).attr("index");
		                }).attr("focused",1).attr("x1",function(d, i){ return width/2;})
		                .attr("y1",function(d, i){ return height/2;})
			            .attr("x2",function(d, i){                       
				                return  (width/2-((matches>nodes_in_wid)?width/2-dep_radius*4/2:dep_radius*4/2*(matches-1))) + (i%nodes_in_wid)*dep_radius*4;
			                })
			            .attr("y2",function(d, i){return x*height/4 - parseInt(i/nodes_in_wid)*dep_radius*4;})
			            .each(function(d, i){
				            var that = this;
				            circles.filter(function() {
					            return d3.select(this).attr("index") == d3.select(that).attr(trgt);
					            }).attr("focused",1)
                                    .attr("transform",function(){
                                        d.xf = (width/2-((matches>nodes_in_wid)?width/2-dep_radius*4/2:dep_radius*4/2*(matches-1))) + (i%nodes_in_wid)*dep_radius*4;
                                        d.yf = x*height/4 - parseInt(i/nodes_in_wid)*dep_radius*4;
						                return "translate(" + d.xf + "," + d.yf + ")";
						            })
                                    .selectAll("circle")
					                .attr("r",dep_radius);
				            });
      
            }
       }
    }});
;// Generated by CoffeeScript 1.7.1
(function() {
  angular.module('DLApp').service('Graph', function($http, $window) {
    return {
      getGraph: function(DLcode, style, callback) {
        if ($window.DL.createGraph) {
          return callback($window.DL.createGraph(DLcode));
        } else {
          return $http.post("/sendDL", {
            'DLcode': DLcode,
            'Shade': style
          }).success(function(data, status, headers, config) {
            return callback($window.DL.Graph(data));
          });
        }
      },
      getTokens: function(DLcode) {
        return $window.DL.tokens(DLcode);
      },
      getFunctions: function() {
        return $window.DL.builtInFunctions;
      }
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.7.1
(function() {
  angular.module('DLApp').service('x2js', function($rootScope) {
    var x2js;
    x2js = new X2JS;
    this.xml2json = function(XML) {
      return x2js.xml_str2json(XML);
    };
    return this;
  });

}).call(this);
