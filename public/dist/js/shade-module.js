// Generated by CoffeeScript 1.7.1
(function() {
  angular.module('ShadeApp', ['ShadeServices', 'ngGrid', 'mgcrea.ngStrap.popover', 'ui.bootstrap']);

}).call(this);
;// Generated by CoffeeScript 1.7.1
(function() {
  angular.module('ShadeApp').directive('shdButton', function($compile, $timeout, $templateCache) {
    return {
      restrict: 'E',
      replace: true,
      scope: true,
      transclude: true,
      template: function(elm, attr) {
        var cbs, events, handlers, toAppend;
        toAppend = '';
        if (attr.controlBlock) {
          cbs = (function() {
            var cb_arr, obj;
            obj = {};
            cb_arr = attr.controlBlock.split(';');
            cb_arr = _.map(cb_arr, function(str) {
              return str.split(/\s?,\s?/);
            });
            _.each(cb_arr, function(arr) {
              obj[arr[0]] = obj[arr[0]] || [];
              return obj[arr[0]].push(arr.slice(1));
            });
            return obj;
          })();
          events = {
            Click: 'ng-click=',
            "default": 'ng-click='
          };
          handlers = {
            setDL: function(name, val) {
              return 'vars[&quot;' + name + '&quot;].model=' + val + ';';
            },
            popup: function(popup, location) {
              return "popup('" + popup + "','" + location + "')";
            }
          };
          _.each(cbs, function(cb, name) {
            return toAppend += (events[name] || events["default"]) + '"' + (_.map(cb, function(el) {
              return handlers[el[0]](el[1], el[2]);
            })).join('') + '" ';
          });
        }
        return '<button ' + toAppend + '>{{vars[vText].model||text}}</button>';
      },
      link: function(scope, elm, attr) {
        scope.vText = attr.vText;
        scope.text = attr.text;
        return scope.popup = function(id, elm) {
          var clone, popup;
          popup = angular.element('#' + id);
          if (popup.attr('container') !== '#' + elm) {
            popup.triggerHandler('leave');
            clone = popup.clone();
            popup.after(clone).remove();
            clone.children().removeAttr('ng-transclude');
            clone.attr({
              'container': '#' + elm,
              'bs-popover': '',
              'trigger': 'manual',
              'template': angular.element('<div />').append(angular.element('<div />').append(angular.element('<div class="popupt"/>').append(clone.children()))).html()
            });
            popup = $compile(clone)(scope);
          }
          $timeout((function() {
            return popup.triggerHandler('popup');
          }), 50);
        };
      }
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.7.1
(function() {
  angular.module('ShadeApp').directive('dropDown', function($filter, $timeout, $rootScope, ngGridFlexibleHeightPlugin) {
    return {
      restrict: 'E',
      replace: true,
      scope: true,
      template: '<table class="dropdown" ng-click="dropdown($event,ghide)"><tr class="selected"><td class="selectedItems">{{selected|selectedArray}}</td><td class="glyphicon glyphicon-chevron-down"></td></tr> <tr class="gridStyle" ng-grid="gridOptions" ng-class="{hide:ghide}" ng-click="select($event)" ng-animate></tr></table>',
      link: {
        pre: function(scope, elm, attr) {
          var header, items;
          header = attr.header.split('|');
          items = attr.items.split(',').map(function(elm) {
            return elm.split('|');
          });
          scope.myData = items.map(function(elm) {
            return elm.reduce((function(obj, el, ind) {
              obj[header[ind]] = el;
              return obj;
            }), {});
          });
          scope.selected = ["Click me"];
          scope.gridOptions = {
            data: 'myData',
            selectedItems: scope.selected,
            multiSelect: attr.multiSelect === 'true',
            plugins: [
              new ngGridFlexibleHeightPlugin({
                maxHeight: 300
              })
            ],
            enableSorting: false,
            rowHeight: 27
          };
          scope.ghide = true;
          scope.dropdown = function($event, state) {
            if (state) {
              $rootScope.$broadcast('fade');
            }
            _.kill_event($event);
            return scope.ghide = !state;
          };
          scope.select = function($event) {
            return _.kill_event($event);
          };
          scope.$on('bg_click', function() {
            return scope.dropdown();
          });
          scope.$on('fade', function() {
            return scope.dropdown();
          });
          return scope.$watchCollection('selected', function() {
            if (attr.multiSelect === 'false') {
              return scope.ghide = true;
            }
          });
        }
      }
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.7.1
(function() {
  angular.module('ShadeApp').directive('format', function(format) {
    return {
      restrict: 'A',
      require: '?ngModel',
      link: {
        pre: function(scope, elm, attr, ngModel) {
          var formatStr;
          formatStr = attr.format;
          if (angular.isDefined(ngModel)) {
            ngModel.$formatters.push(function(value) {
              if (angular.isNumber(value)) {
                return value = format(value, formatStr);
              }
            });
            ngModel.$parsers.unshift(function(value) {
              if (isNaN(value)) {
                value = ngModel.$modelValue;
              }
              return +value;
            });
            return elm.on('blur', function() {
              if (isNaN(elm.val())) {
                return elm.val(format(+ngModel.$modelValue, formatStr));
              } else {
                return elm.val(format(+elm.val(), formatStr));
              }
            });
          }
        }
      }
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.7.1
(function() {
  angular.module('ShadeApp').directive('numUpDown', function($timeout, format) {
    return {
      restrict: 'E',
      scope: false,
      template: function(elm, attr) {
        var getAttrs;
        getAttrs = function() {
          var args;
          args = arguments;
          return _.reduce(args, function(str, val) {
            return str + val + '="' + attr[val] + '" ';
          }, '');
        };
        return '<div class="input-group">' + '<input style="width:90%" class="form-control" type="text" ng-model="vars[vText].model" dvalue="' + getAttrs('dvalue', 'min', 'max', 'format') + '"/>' + '<div class="btn-group-vertical">' + '<button class="btn btn-default" ng-mousedown="increase()" ng-mouseup="stop()" ng-mouseout="stop()">' + '<span class="glyphicon glyphicon-chevron-up" />' + '</button>' + '<button class="btn btn-default" ng-mousedown="decrease()" ng-mouseup="stop()" ng-mouseout="stop()">' + '<span class="glyphicon glyphicon-chevron-down" />' + '</button>' + '</div>' + '</div>';
      },
      link: function(scope, elm, attr) {
        var change, cto, formatStr, maxVal, minVal, mtimeout, step, test, timeout, updateModel;
        scope.vText = attr.vText;
        test = null;
        step = 1;
        minVal = +attr.min;
        maxVal = +attr.max;
        formatStr = attr.format;
        timeout = 300;
        mtimeout = 30;
        cto = null;
        updateModel = function(value) {
          value = +value;
          if (scope.vars && _.isFinite(value)) {
            return scope.vars[scope.vText].model = (value > maxVal ? maxVal : (value < minVal ? minVal : value));
          }
        };
        $timeout(function() {
          return updateModel(+attr.dvalue);
        });
        change = function(d) {
          if (timeout > mtimeout) {
            timeout -= 30;
          }
          $timeout(function() {
            return updateModel(scope.vars[scope.vText].model + d);
          });
          return cto = setTimeout(change, timeout, d);
        };
        scope.increase = _.partial(change, 1);
        scope.decrease = _.partial(change, -1);
        return scope.stop = function() {
          clearTimeout(cto);
          return timeout = 300;
        };
      }
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.7.1
(function() {
  angular.module('ShadeApp').directive('renderPanel', function($compile, $rootScope, shadeTemplate, shadeData) {
    return {
      restrict: 'E',
      scope: {
        vars: '=',
        graph: '=',
        styles: '='
      },
      controller: function($element, $scope) {
        this.render = function() {
          if (shadeData.set(shadeTemplate.toHTML($scope.styles))) {
            $element.html('<style>' + shadeData.getStyles() + '</style>' + shadeData.getBody());
            return $compile($element.contents())($scope);
          }
        };
        $rootScope.$on('Run', this.render);
      }
    };
  }).directive('vSub', function($compile, shadeData, shadeTemplate, x2js) {
    return {
      restrict: 'A',
      link: function(scope, elm, attr) {
        scope.vSub = attr.vSub;
        return scope.$watch('vSub', function() {
          var body, content, shadeNode;
          shadeNode = shadeData.getElementById(attr.shdId);
          shadeNode.Sub.Node.push((x2js.xml2json(scope.vars[scope.vSub].model)).Node);
          content = shadeTemplate.toHTML({
            Shade: {
              Node: shadeNode
            }
          });
          body = angular.element(content.body);
          elm.html(body.html());
          return $compile(elm.contents())(scope);
        });
      }
    };
  }).directive('prettyPrintPanel', function($filter, shadeTemplate) {
    return {
      restrict: 'A',
      replace: true,
      template: '<div class="pp-panel"></div>',
      link: function(scope, elm, attrs) {
        return scope.$watch(attrs.prettyPrintPanel, function(shade) {
          var code, pre, raw_html;
          raw_html = $filter('indentHTML')((shadeTemplate.toHTML(shade) || {
            body: ''
          }).body);
          pre = angular.element('<pre class="prettyprint lang-html" style="font-size:0.75em"></pre>');
          code = angular.element('<code></code>');
          code.html($filter('escapeHTML')(raw_html));
          pre.append(code);
          elm.html(pre);
          return prettyPrint();
        });
      },
      controller: function($scope, $http) {
        var themes;
        $scope.themes = themes = {
          list: ['google-code-light', 'solarized-dark', 'solarized-light', 'sons-of-obsidian-dark', 'tomorrow-night-blue', 'tomorrow-night-dark', 'tomorrow-night-light', 'tomorrow-night-eighties'],
          selected: 'google-code-light'
        };
        return $scope.$watch('themes.selected', function(theme_name) {
          var url;
          url = "styles/gprettify/" + theme_name + ".css";
          return $http.get(url).then(function(response) {
            return themes.css = response.data;
          });
        });
      }
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.7.1
(function() {
  angular.module('ShadeApp').directive('shdImage', function($http) {
    return {
      restrict: 'E',
      replace: true,
      scope: true,
      require: '?ngModel',
      template: '<img ng-model="vars[vText].model" />',
      link: function(scope, elm, attr, ngModel) {
        scope.src = attr.src;
        scope.vText = attr.vText;
        if (angular.isDefined(ngModel)) {
          return ngModel.$render = function() {
            return $http.head(ngModel.$modelValue || 'default').success(function() {
              return elm.attr('src', ngModel.$modelValue);
            }).error(function() {
              return elm.attr('src', scope.src);
            });
          };
        }
      }
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.7.1
(function() {
  angular.module('ShadeApp').directive('vActiveTabIndex', function() {
    return {
      restrict: 'A',
      link: function(scope, elm, attr) {
        scope.vactive = attr.vActiveTabIndex;
        scope.$watch('vars[vactive].model', function(vactive) {
          vactive = Number(vactive);
          if (angular.isDefined(scope.tabs[vactive])) {
            return _.each(scope.tabs, function(tab, ind) {
              tab.active = false;
              if (ind === vactive) {
                return tab.active = true;
              }
            });
          }
        });
        return scope.$watch('active', function(active) {
          return scope.vars[scope.vactive].model = active;
        });
      }
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.7.1
(function() {
  angular.module('ShadeApp').directive('listBox', function(vTextProvider) {
    return new vTextProvider('<select multiple ng-transclude />');
  }).directive('inputs', function(vTextProvider) {
    return new vTextProvider('<input />');
  }).directive('shdDatePicker', function(vTextProvider) {
    return new vTextProvider('<input type="text" datepicker-popup close-on-date-selection="false" />');
  }).directive('timePicker', function(vTextProvider) {
    return new vTextProvider('<div><timepicker /></div>');
  });

}).call(this);
;// Generated by CoffeeScript 1.7.1
(function() {
  angular.module('ShadeApp').factory('ngGridFlexibleHeightPlugin', function() {
    var ngGridFlexibleHeightPlugin;
    return ngGridFlexibleHeightPlugin = function(opts) {
      var self;
      self = this;
      self.grid = null;
      self.scope = null;
      self.init = function(scope, grid, services) {
        var innerRecalcForData, recalcHeightForData;
        self.domUtilityService = services.DomUtilityService;
        self.grid = grid;
        self.scope = scope;
        recalcHeightForData = function() {
          setTimeout(innerRecalcForData, 1);
        };
        innerRecalcForData = function() {
          var extraHeight, footerPanelSel, gridId, naturalHeight, newViewportHeight;
          gridId = self.grid.gridId;
          footerPanelSel = "." + gridId + " .ngFooterPanel";
          extraHeight = self.grid.$topPanel.height() + $(footerPanelSel).height();
          naturalHeight = self.grid.$canvas.height() + 1;
          if (opts != null) {
            if ((opts.minHeight != null) && (naturalHeight + extraHeight) < opts.minHeight) {
              naturalHeight = opts.minHeight - extraHeight - 2;
            }
            if ((opts.maxHeight != null) && (naturalHeight + extraHeight) > opts.maxHeight) {
              naturalHeight = opts.maxHeight - extraHeight - 2;
            }
          }
          newViewportHeight = naturalHeight + 2;
          if (!self.scope.baseViewportHeight || self.scope.baseViewportHeight !== newViewportHeight) {
            self.grid.$viewport.css("height", newViewportHeight + "px");
            self.grid.$root.css("height", (newViewportHeight + extraHeight) + "px");
            self.scope.baseViewportHeight = newViewportHeight;
            self.domUtilityService.RebuildGrid(self.scope, self.grid);
          }
        };
        self.scope.catHashKeys = function() {
          var hash, idx;
          hash = "";
          idx = void 0;
          for (idx in self.scope.renderedRows) {
            hash += self.scope.renderedRows[idx].$$hashKey;
          }
          return hash;
        };
        self.scope.$watch("catHashKeys()", innerRecalcForData);
        self.scope.$watch(self.grid.config.data, recalcHeightForData);
      };
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.7.1
(function() {


}).call(this);
;// Generated by CoffeeScript 1.7.1
(function() {
  angular.module("ShadeApp").filter("selectedArray", function() {
    return function(arr) {
      if (_.isString(arr[0]) && arr.length === 1) {
        return arr[0];
      }
      return _.reduce(arr, (function(str, item, ind) {
        if (_.isPlainObject(item)) {
          return str + _.values(item) + (ind !== arr.length - 1 ? ";" : '');
        } else {
          return str;
        }
      }), "");
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.7.1
(function() {
  angular.module('ShadeApp').service('format', function() {
    return function(input, str) {
      var i, length, matches, output, replacer;
      if (angular.isNumber(input)) {
        input = input.toString();
        replacer = function(match) {
          if (input[i] === ".") {
            i++;
          }
          return input[i++] || (match === "#" ? "" : "0");
        };
        length = parseInt(input, 10).toString().length;
        matches = str.match(/[0#](?=.*\.)/g).length;
        i = length - matches;
        return output = str.replace(/[\s,]/g, '').replace(/[0#]/g, replacer);
      }
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.7.1
(function() {
  angular.module('ShadeApp').service('shadeData', function() {
    var data;
    data = {};
    this.set = function(_data) {
      return data = _data;
    };
    this.get = function() {
      return data;
    };
    this.getElementById = function(id) {
      return data.elementsById[id];
    };
    this.getStyles = function() {
      return data.styles;
    };
    this.getBody = function() {
      return data.body;
    };
    return this;
  });

}).call(this);
;// Generated by CoffeeScript 1.7.1
(function() {
  angular.module("ShadeApp").service("ShadeIdentifiers", function(ShadeStaticHandlers, ShadeHandlers) {
    var sh, sw;
    sh = ShadeStaticHandlers;
    sw = ShadeHandlers;
    return (function(key, an, av, sn, sv, c, cb, mn) {
      return {
        attrNames: {
          type: "Attribute Name",
          keys: key(an || {})
        },
        attrValues: {
          type: "Attribute Value",
          keys: key(av || {})
        },
        styleNames: {
          type: "Style Name",
          keys: key(sn || {})
        },
        styleValues: {
          type: "Style Value",
          keys: key(sv || {})
        },
        controls: {
          type: "Control",
          keys: key(c || {})
        },
        controlBlocks: {
          type: "Control Block",
          keys: key(cb || {})
        },
        mainNodes: {
          type: "",
          keys: key(mn || {})
        }
      };
    })(Object.keys, sh.attrNameHandlers, sh.attrValueHandlers, sh.styleNameHandlers, sh.styleValueHandlers, sw.UIHandlers, sw.CbHandlers, sw.nodeHandlers);
  }).service("ShadeAttrDictionary", function(ShadeStaticHandlers) {
    return {
      attrNameHandlers: ShadeStaticHandlers.attrNameHandlers,
      attrValueHandlers: ShadeStaticHandlers.attrValueHandlers
    };
  });

}).call(this);
;// Generated by CoffeeScript 1.7.1
(function() {
  angular.module('ShadeApp').service('shadeTemplate', function($http, x2js, ShadeParser, ShadeAttrDictionary) {
    var template;
    template = function() {};
    $http.get('/scripts/Shade/ng_template_shd.ejs').success(function(data) {
      _.templateSettings.variable = "shd";
      return template = _.template(data);
    }).error(function() {
      return console.log("could not retrieve shade template");
    });
    this.toHTML = function(shade) {
      var parsed;
      if (!angular.isObject(shade)) {
        shade = x2js.xml2json(shade);
      }
      parsed = ShadeParser.parse(shade) || {};
      _.extend(parsed, ShadeAttrDictionary);
      return {
        body: template(parsed),
        styles: parsed.styles,
        elementsById: parsed.elementsById
      };
    };
    return this;
  });

}).call(this);
